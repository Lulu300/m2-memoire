\documentclass[memoire.tex]{subfiles}

\chapter{Comment évaluer l'architecture résultant de l'application des critères}

Maintenant que nous avons réussi à définir des critères de choix pour notre architecture Big Data, il reste encore une étape pour s'assurer que les critères que nous avons définis sont corrects. Pour cela, il va falloir tester notre démarche en s'appuyant sur des cas d'utilisations réels.

\section{Application des critères définis sur des cas d'utilisations réels}

Dans un premier temps, il faut appliquer notre démarche à des cas d'utilisations réels. Pour cela, nous allons détailler les types de sources de données qui correspondent au cas d'utilisation que nous avons choisi, le type de traitement nécessaire sur ces données ainsi que la valeur que l'on veut dégager à l'aide de nos analyses sur ces données. Une fois cela fait, nous allons nous appuyer sur les critères réalisés lors de la partie précédente et lister les solutions logicielles qui ont été retenues. Une fois cette étape terminée, nous allons traiter un par un chaque cas d'utilisation. Pour chacun de ces cas d'utilisation, nous allons mettre en place les solutions logicielles issues de nos critères, ce qui nous permettra de tester notre solution dans des conditions réelles.

\section{Évaluation des résultats}

Une fois la mise en place de notre solution, afin de pouvoir mesurer son efficacité, il faudra réaliser des benchmarks et laisser la solution en place pendant quelques heures. Pendant que les données arriveront dans notre architecture, nous pourrons nous concentrer sur la réalisation des visualisations et des analyses à effectuer sur les données. Cela permettra de vérifier si la solution sélectionnée nous permet bien de réaliser sans encombre la mise en valeur que le cas d'utilisation nécessitait. En plus des résultats des benchmarks et de la réussite à faire les analyses nécessaires, il faudra aussi évaluer si tout le chemin de la donnée a bien été parcouru sans souci. Par exemple est-ce qu'il n'a pas fallu faire du développement spécifique qui n'était pas prévu pour permettre la communication entre plusieurs briques, ou bien pour effectuer le traitement des données ou encore pour le stockage des données? Maintenant que nous avons pu nous rendre compte de la performance de cette solution, nous allons mettre d'autres architectures avec d'autres solutions logicielles et essayer d'y appliquer le même cas d'utilisation. Nous effectuerons les mêmes tests, et à la fin nous pourrons donc facilement voir si l'architecture émise par l'application de nos critères était celle qui s'adapte le mieux au cas d'utilisation. Ensuite, nous répéterons ces étapes pour tous les autres cas d'utilisation sélectionnés pour vérifier que pour chacun d'entre eux, nos critères avaient dégagé la meilleure architecture.
